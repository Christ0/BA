#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_vulkan_glsl : enable
#extension GL_ARB_compute_variable_group_size : enable

const int TILE_SIZE = 16;

struct PointLight {
	vec3 pos;
	float radius;
	vec3 intensity;
};

#define MAX_POINT_LIGHT_PER_TILE 1023
struct LightVisiblity{
	uint count;
	uint lightindices[MAX_POINT_LIGHT_PER_TILE];
};

layout(push_constant) uniform PushConstandObject{
	ivec2 viewportSize;
	ivec2 tileNums;
}pushConstants;

layout(std430, set = 0, binding = 0) writeonly buffer TileLightVisiblities{
    LightVisiblity light_visiblities[];
};

layout(std140, set = 0, binding = 1) readonly buffer PointLights{ 
	int light_num;
	PointLight pointlights[2000];
};

layout(std140, set = 1, binding = 0) readonly buffer CameraUbo{ 
    mat4 view;
    mat4 proj;
    mat4 projview;
    vec3 cameraPos;
} camera;

layout(set = 2, binding = 0) uniform sampler2D depth_sampler;

// vulkan ndc, minDepth = 0.0, maxDepth = 1.0
// ndc = normalized device coordinates, -1 bis 1 für X Y und Z
const vec2 ndcUpperLeft = vec2(-1.0, -1.0);

struct ViewFrustum{
	vec4 planes[6];
	vec3 corners[8]; // 0-3 near 4-7 far
};

layout(local_size_x = TILE_SIZE) in;
//layout(local_size_variable) in;

shared ViewFrustum frustum;
shared uint lightCountForTile;
shared float minDepth;
shared float maxDepth;

ViewFrustum createFrustum(ivec2 tileID){
	mat4 inv_projview = inverse(camera.projview);
	vec2 ndcSizePerTile = 2.0 * vec2(TILE_SIZE, TILE_SIZE) / pushConstants.viewportSize;

	vec2 ndcCorners[4];  // Ecken des Tiles in ndc
	ndcCorners[0] = ndcUpperLeft + tileID * ndcSizePerTile;			 // upper left
	ndcCorners[1] = vec2(ndcCorners[0].x + ndcSizePerTile.x, ndcCorners[0].y); // upper right
	ndcCorners[2] = ndcCorners[0] + ndcSizePerTile;						 // lower right
	ndcCorners[3] = vec2(ndcCorners[0].x, ndcCorners[0].y + ndcSizePerTile.y); // lower left
	
	ViewFrustum frustum;

	vec4 temp;
	for (int i = 0; i < 4; i++){
		temp = inv_projview * vec4(ndcCorners[i], minDepth, 1.0);
		frustum.corners[i] = temp.xyz / temp.w;
		temp = inv_projview * vec4(ndcCorners[i], maxDepth, 1.0);
		frustum.corners[i + 4] = temp.xyz / temp.w;
	}

	vec3 temp_normal;
	for (int i = 0; i < 4; i++){
		// temp_normal: normal ohne normalisation
		temp_normal = cross(frustum.corners[i] - camera.cameraPos, frustum.corners[i + 1] - camera.cameraPos); //Normalenvektor einer Ebene des Frustums
		temp_normal = normalize(temp_normal);
		frustum.planes[i] = vec4(temp_normal, - dot(temp_normal, frustum.corners[i])); //Entfernung zum Ursprung
	}
	// near plane
	{
		temp_normal = cross(frustum.corners[1] - frustum.corners[0], frustum.corners[3] - frustum.corners[0]);
		temp_normal = normalize(temp_normal);
		frustum.planes[4] = vec4(temp_normal, - dot(temp_normal, frustum.corners[0]));
	}
	// far plane
	{
		temp_normal = cross(frustum.corners[7] - frustum.corners[4], frustum.corners[5] - frustum.corners[4]);
		temp_normal = normalize(temp_normal);
		frustum.planes[5] = vec4(temp_normal, - dot(temp_normal, frustum.corners[4]));
	}
	return frustum;
}


bool isCollided(PointLight light, ViewFrustum frustum){
	bool result = true;
	//Sphere-Plane-Test
	for (int i = 0; i < 6; i++){
		if (dot(light.pos, frustum.planes[i].xyz) + frustum.planes[i].w  < - light.radius ){
			result = false; //außerhalb des Frustums
			break;
		}
	}
	if(!result){
		return false;
	}

	//Bbox corner test für weniger false positives
	vec3 lightBboxMax = light.pos + vec3(light.radius);
    vec3 lightBboxMin = light.pos - vec3(light.radius);
    int probe;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].x > lightBboxMax.x)?1:0); if( probe==8 ) return false;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].x < lightBboxMin.x)?1:0); if( probe==8 ) return false;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].y > lightBboxMax.y)?1:0); if( probe==8 ) return false;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].y < lightBboxMin.y)?1:0); if( probe==8 ) return false;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].z > lightBboxMax.z)?1:0); if( probe==8 ) return false;
    probe=0; for( int i=0; i<8; i++ ) probe += ((frustum.corners[i].z < lightBboxMin.z)?1:0); if( probe==8 ) return false;

	return true;
}

void main(){
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	uint tile_index = tileID.y * pushConstants.tileNums.x + tileID.x;

	if (gl_LocalInvocationIndex == 0){
		minDepth = 1.0;
		maxDepth = 0.0;
		
		for (int y = 0; y < TILE_SIZE; y++){
			for (int x = 0; x < TILE_SIZE; x++){
				vec2 sample_loc = (vec2(TILE_SIZE, TILE_SIZE) * tileID + vec2(x, y) ) / pushConstants.viewportSize;
				float pre_depth = texture(depth_sampler, sample_loc).x;
				minDepth = min(minDepth, pre_depth);
				maxDepth = max(maxDepth, pre_depth);
			}
		}

		if (minDepth >= maxDepth){
			minDepth = maxDepth;
		}

		frustum = createFrustum(tileID);
		lightCountForTile = 0;
	}

	barrier();

	for (uint i = gl_LocalInvocationIndex; i < light_num && lightCountForTile < MAX_POINT_LIGHT_PER_TILE; i += gl_WorkGroupSize.x){
		if (isCollided(pointlights[i], frustum)){
			uint slot = atomicAdd(lightCountForTile, 1);
			if (slot >= MAX_POINT_LIGHT_PER_TILE) {break;}
			light_visiblities[tile_index].lightindices[slot] = i;
		}
	}

	barrier();

	if (gl_LocalInvocationIndex == 0){
		light_visiblities[tile_index].count = min(MAX_POINT_LIGHT_PER_TILE, lightCountForTile);
	}
}